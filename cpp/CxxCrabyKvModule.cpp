// Auto generated by Craby. DO NOT EDIT.
#include "CxxCrabyKvModule.hpp"
#include "cxx.h"
#include "bridging-generated.hpp"
#include <react/bridging/Bridging.h>

using namespace facebook;

namespace craby {
namespace crabykv {

std::string CxxCrabyKvModule::dataPath = std::string();

CxxCrabyKvModule::CxxCrabyKvModule(
    std::shared_ptr<react::CallInvoker> jsInvoker)
    : TurboModule(CxxCrabyKvModule::kModuleName, jsInvoker) {
  // No signals
  callInvoker_ = std::move(jsInvoker);
  module_ = std::shared_ptr<craby::bridging::CrabyKv>(
    craby::bridging::createCrabyKv(
      reinterpret_cast<uintptr_t>(this),
      rust::Str(dataPath.data(), dataPath.size())).into_raw(),
    [](craby::bridging::CrabyKv *ptr) { rust::Box<craby::bridging::CrabyKv>::from_raw(ptr); }
  );
  threadPool_ = std::make_shared<craby::utils::ThreadPool>(10);
  methodMap_["clear"] = MethodMetadata{0, &CxxCrabyKvModule::clear};
  methodMap_["contains"] = MethodMetadata{1, &CxxCrabyKvModule::contains};
  methodMap_["get"] = MethodMetadata{1, &CxxCrabyKvModule::get};
  methodMap_["initialize"] = MethodMetadata{0, &CxxCrabyKvModule::initialize};
  methodMap_["keys"] = MethodMetadata{0, &CxxCrabyKvModule::keys};
  methodMap_["remove"] = MethodMetadata{1, &CxxCrabyKvModule::remove};
  methodMap_["set"] = MethodMetadata{2, &CxxCrabyKvModule::set};
  methodMap_["size"] = MethodMetadata{0, &CxxCrabyKvModule::size};
}

CxxCrabyKvModule::~CxxCrabyKvModule() {
  invalidate();
}

void CxxCrabyKvModule::invalidate() {
  if (invalidated_.exchange(true)) {
    return;
  }

  invalidated_.store(true);
  listenersMap_.clear();

  // No signals

  // Shutdown thread pool
  threadPool_->shutdown();
}

jsi::Value CxxCrabyKvModule::clear(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyKvModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::bridging::clear(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyKvModule::contains(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyKvModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::bridging::contains(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyKvModule::get(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyKvModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::bridging::get(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyKvModule::initialize(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyKvModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::bridging::initialize(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyKvModule::keys(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyKvModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::bridging::keys(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyKvModule::remove(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyKvModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    craby::bridging::remove(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyKvModule::set(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyKvModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto arg1$raw = args[1].asString(rt).utf8(rt);
    auto arg1 = rust::Str(arg1$raw.data(), arg1$raw.size());
    craby::bridging::set(*it_, arg0, arg1);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyKvModule::size(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyKvModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::bridging::size(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::utils::errorMessage(err));
  }
}

} // namespace crabykv
} // namespace craby
